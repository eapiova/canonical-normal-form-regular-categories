(** A closure sytem is given by a family of rules, from which we inductively generate
    elements, starting from a set of elements. *)

Require Import HoTT.
Require Import Auxiliary.Family.

(* A rule on [X] gives a family of "premises" and a "conclusion", so it is a kind of
   abstract inference rule. *)
Local Record rule (X : Type) :=
  {
    premises : family X ;
    conclusion : X
  }.

Arguments premises [_] _.
Arguments conclusion [_] _.

(* TODO: consider naming conventions for such lemmas. *)
Local Definition rule_eq {X} {c c' : rule X}
  : premises c = premises c'
  -> conclusion c = conclusion c'
  -> c = c'.
Proof.
  destruct c, c'; cbn.
  intros e e'; destruct e, e'.
  apply idpath.
Defined.

(** Map a rule in [X] to a rule in [Y] along a map [f : X -> Y]. *)
Local Definition fmap {X Y} (f : X -> Y) : rule X -> rule Y.
Proof.
  intros [ps c].
  exact {| premises := Family.fmap f ps ; conclusion := f c |}.
Defined.

(** A closure system is a family of rules. *)
Local Definition system (X : Type) := family (rule X).

(** Derivations generated by the given family of rules [C] and hypotheses [H].  *)
Local Inductive derivation {X} (C : system X) (H : family X) : X -> Type :=
  | hypothesis : forall (i : H), derivation C H (H i)
  | deduce (r : C) :
      (forall (p : premises (C r)), derivation C H (premises (C r) p))
      -> derivation C H (conclusion (C r)).

(** Due to the dependency in conclusions, it is often tricky to give derivations
in tactic proofs: [apply hypothesis], [apply deduce] often fail to unify.

The following lemmas allow one to write e.g.:

    simple refine (Closure.deduce' _ _ _).
    - (interactively select the desired rule) 
    - (show it has the right conclusion; often just [apply idpath])
    - (now derive the premises)

      simple refine (Closure.hypothesis' _ _).
    - (interactively select the desired hypothesis) 
    - (show it has the right conclusion; often just [apply idpath])
*)
Local Definition deduce' {X} {C : system X} {H : family X}
  {x : X} (r : C) (e : conclusion (C r) = x)
  (d_prems : forall p : premises (C r), derivation C H (premises (C r) p))
  : derivation C H x
:= transport _ e (deduce C H r d_prems).

Local Definition hypothesis' {X} {C : system X} {H : family X}
  {x : X} (h : H) (e : H h = x)
  : derivation C H x
:= transport _ e (hypothesis C H h).

(** Given a derivation [d] from hypotheses [H], and for each hypothesis [h]
    a derivation of it from hypotheses [G], we can graft the derivations onto
    [d] to get a derivation from hypotheses [G]. *)
Local Definition graft {X} (C : system X)
    {H} {x} (d : derivation C H x)
    {G} (f : forall i : H, derivation C G (H i))
  : derivation C G x.
Proof.
  induction d.
  (* hypothesis *)
  - now apply f.
  (* deduction step *)
  - now apply (deduce _ _ r).
Defined.

(** For using [graft] interactively, similar to [deduce'], [hypothesis']. 
 Use as:

  refine (graft _ _ _).
  - (give derivation d for grafting) 
  - (show it has correct conclusion)
  - (derive premises of d)

*)
Local Definition graft' {X} {C : system X}
    {H} {x} {x'} (d : derivation C H x') (e : x' = x)
    {G} (f : forall i : H, derivation C G (H i))
  : derivation C G x
:= transport _ e (graft C d f).

(** In general, one can consider maps between closure systems _over_ maps between the sets they’re on, in the sense of a _displayed category_ (arXiv:1705.04296).

  A map from a closure system [C] on [X] to a closure system [D] on [Y], over [f : X -> Y] gives for each rule [C i] of [C] a derivation in [D] of the conclusion of [C i] from the premises of [C i]. *)
Local Definition map_over {X Y} (f : X -> Y) (C : system X) (D : system Y)
  : Type
:= forall i : C, derivation D
     (Family.fmap f (premises (C i))) (f (conclusion (C i))).

(** A map from a closure system [C] to a closure system [D] gives, for each
    rule [C i] in [C i] in [C], a derivation in [D] of the conclusion of [C i]
    from the premises of [C i]. *)
Local Definition map {X} (C D : system X) : Type
  := map_over idmap C D.

(** We can of always map a closure system to itself by deducing the
    conclusion of every rule by simply applying the rule. *)
Local Definition idmap {X} (C : system X) : map C C.
Proof.
  intro i.
  apply deduce.
  intro p.
  now apply hypothesis.
Defined.

(** More generally, a family map between closure systems gives a closure map between them.

An alternative point of view here is that family maps could be taken as the basic maps between closure systems; closure system maps are then Kleisli maps for the monad sending a closure system to its family of derivability conditions, and this definition is then the unit map of that monad.  We do not take that approach as primary since it creates various complications, e.g. size issues.  *)
Local Definition map_from_family_map
    {X Y} {f : X -> Y} {C : system X} {D : system Y}
  : Family.map_over (fmap f) C D -> map_over f C D.
Proof.
  intros ff i.
  refine (deduce' (ff i) _ _).
  - refine (ap _ (Family.map_over_commutes _ _)).
  - set (Df := premises (D (ff i))) in *.
    set (e := ap _ (Family.map_over_commutes ff i)^ : _ = Df).
    destruct e.
    intro p. apply hypothesis.
Defined.

(** Given a closure system map from [C] to [D],
   we can map derivations over [C] to derivations over [D]. *)
Local Fixpoint fmap_derivation_over
    {X Y} {f : X -> Y} {C : system X} {D : system Y} (ff : map_over f C D)
    {H} {x} (d : derivation C H x)
  : derivation D (Family.fmap f H) (f x).
Proof.
  destruct d as [i | r d_prems].
  - refine (hypothesis _ (Family.fmap f H) i).
  - refine (graft _ (ff r) _).
    intro i. apply (fmap_derivation_over _ _ _ _ _ ff), d_prems.
Defined.

Arguments fmap_derivation_over : simpl nomatch.

(** Although [fmap_derivation] is just a special case of [map_derivation_over],
 it is given separately since the specialised statement works better in
 interactive proofs.

 Specifically, while [Family.fmap idmap H] is in fact judgementally
 equal to [H], the unification performed by [apply] doesn’t always recognise
 this. *)
Local Definition fmap_derivation
    {X} {C D : system X} (f : map C D)
    {H} {x} (d : derivation C H x)
  : derivation D H x
:= fmap_derivation_over f d.

Arguments fmap_derivation : simpl nomatch.

(** Derivations are also functorial in their hypotheses. *)
Local Definition derivation_fmap2
    {X} {T : system X} {H H'} (f : Family.map H H') {x}
    (D : derivation T H x)
  : derivation T H' x.
Proof.
  refine (graft _ D _); intros i.
  apply (hypothesis' (f i)).
  apply Family.map_commutes.
Defined.

Local Definition inl {X} {C D : system X}
  : map C (C + D)
:= map_from_family_map Family.inl.

Local Definition inr {X} {C D : system X}
  : map D (C + D)
:= map_from_family_map Family.inr.

(** Analogue of [Family.fmap_of_sum] (see note there re naming conventions) *)
Local Definition fmap_sum
    {X Y} {f : X -> Y}
    {C} {D} (ff : map_over f C D)
    {C'} {D'} (ff' : map_over f C' D')
  : map_over f (Family.sum C C') (Family.sum D D').
Proof.
  intros [r | r'].
  - exact (fmap_derivation inl (ff _)).
  - exact (fmap_derivation inr (ff' _)).
 Defined.

Local Lemma sum_rect {X} {Y} {f : X -> Y}
    {K1 K2} {L} (ff1 : map_over f K1 L) (ff2 : map_over f K2 L)
  : map_over f (K1 + K2) L.
Proof.
  intros [ x | x ]; [apply ff1 | apply ff2].
Defined.

(** Having a hypothesis of [x] is equivalent to having [x] as an axiom in the closure system. It’s sometimes convenient to have both these options available, and convert between them. *)
Local Definition axiom {X} (x:X) : rule X
  := {| premises := [<>]; conclusion := x |}.

Local Definition axioms {X} (H : family X) : system X
  := Family.fmap axiom H.

Definition axioms_vs_hypotheses {X}
    (T : system X) (H1 H2 : family X) (x:X)
  : derivation T (H1 + H2) x
  <-> derivation (T + axioms H1) H2 x.
Proof.
  split.
  - intro d. refine (graft _ (fmap_derivation inl d) _).
    intros [h1 | h2].
    + refine (deduce (T+Family.fmap axiom H1) _ (Datatypes.inr h1) _).
      intros [].
    + exact (hypothesis _ _ h2).
  - intros d; induction d as [ h2 | [r | h1] _ ds ].
    + exact (hypothesis _ (_+_) (Datatypes.inr h2)).
    + exact (deduce _ _ r ds). 
    + exact (hypothesis _ (H1+_) (Datatypes.inl h1)).
Defined.