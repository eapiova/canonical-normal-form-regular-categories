(** A closure sytem is given by a family of rules, from which we inductively generate
    elements, starting from a set of elements. *)

Require Import HoTT.
Require Import Auxiliary.Family.

(* A rule on [X] gives a family of "premises" and a "conclusion", so it is a kind of
   abstract inference rule. *)
Local Record rule (X : Type) :=
  {
    rule_premises : family X ;
    rule_conclusion : X
  }.

Arguments rule_premises [_] _.
Arguments rule_conclusion [_] _.

(* TODO: consider naming conventions for such lemmas. *)
Local Definition rule_eq {X} {c c' : rule X}
  : rule_premises c = rule_premises c'
  -> rule_conclusion c = rule_conclusion c'
  -> c = c'.
Proof.
  destruct c, c'; cbn.
  intros e e'; destruct e, e'.
  apply idpath.
Defined.

(** Map a rule in [X] to a rule in [Y] along a map [f : X -> Y]. *)
Local Definition fmap {X Y} (f : X -> Y) : rule X -> rule Y.
Proof.
  intros [ps c].
  exact {| rule_premises := Family.fmap f ps ; rule_conclusion := f c |}.
Defined.

(** A closure system is a family of rules. *)
Local Definition system (X : Type) := family (rule X).

(** Derivations generated by the given family of rules [C] and hypotheses [H].  *)
Local Inductive derivation {X} (C : system X) (H : family X) : X -> Type :=
  | hypothesis : forall (i : H), derivation C H (H i)
  | deduce (r : C) :
      (forall (p : rule_premises (C r)), derivation C H (rule_premises (C r) p))
      -> derivation C H (rule_conclusion (C r)).

(** Due to the dependency in conclusions, it is often tricky to give derivations
in tactic proofs: [apply hypothesis], [apply deduce] often fail to unify.

The following lemmas allow one to write e.g.:

    simple refine (Closure.deduce' _ _ _).
    - (interactively select the desired rule) 
    - (show it has the right conclusion; often just [apply idpath])
    - (now derive the premises)

      simple refine (Closure.hypothesis' _ _).
    - (interactively select the desired hypothesis) 
    - (show it has the right conclusion; often just [apply idpath])
*)
Local Definition deduce' {X} {C : system X} {H : family X}
  {x : X} (r : C) (e : rule_conclusion (C r) = x)
  (d_prems : forall p : rule_premises (C r), derivation C H (rule_premises (C r) p))
  : derivation C H x
:= transport _ e (deduce C H r d_prems).

Local Definition hypothesis' {X} {C : system X} {H : family X}
  {x : X} (h : H) (e : H h = x)
  : derivation C H x
:= transport _ e (hypothesis C H h).

(** Given a derivation [d] from hypotheses [H], and for each hypothesis [h]
    a derivation of it from hypotheses [G], we can graft the derivations onto
    [d] to get a derivation from hypotheses [G]. *)
Local Definition graft {X} (C : system X)
    {H} {x} (d : derivation C H x)
    {G} (f : forall i : H, derivation C G (H i))
  : derivation C G x.
Proof.
  induction d.
  (* hypothesis *)
  - now apply f.
  (* deduction step *)
  - now apply (deduce _ _ r).
Defined.

(** For using [graft] interactively, similar to [deduce'], [hypothesis']. 
 Use as:

  refine (graft _ _ _).
  - (give derivation d for grafting) 
  - (show it has correct conclusion)
  - (derive premises of d)

*)
Local Definition graft' {X} {C : system X}
    {H} {x} {x'} (d : derivation C H x') (e : x' = x)
    {G} (f : forall i : H, derivation C G (H i))
  : derivation C G x
:= transport _ e (graft C d f).

(** A map from a closure system [C] to a closure system [D] gives, for each
    rule [C i] in [C i] in [C], a derivation in [D] of the conclusion of [C i]
    from the premises of [C i]. *)
Local Definition map {X} (C D : system X) : Type
  := forall i : C, derivation D (rule_premises (C i)) (rule_conclusion (C i)).

(** We can of always map a closure system to itself by deducing the
    conclusion of every rule by simply applying the rule. *)
Local Definition idmap {X} (C : system X) : map C C.
Proof.
  intro i.
  apply deduce.
  intro p.
  now apply hypothesis.
Defined.

(** More generally, a family map between closure systems gives a closure map between them.

An alternative point of view here is that family maps could be taken as the basic maps between closure systems; closure system maps are then Kleisli maps for the monad sending a closure system to its family of derivability conditions, and this definition is then the unit map of that monad.  We do not take that approach as primary since it creates various complications, e.g. size issues.  *)
Local Definition map_from_family_map
     {X} {C D : system X} (f : Family.map C D)
   : map C D.
Proof.
  intro i.
  eapply paths_rew.
  - apply (deduce _ _ (f i)).
    set (Df := rule_premises (D (f i))) in *.
    set (e := ap _ (Family.map_commutes f i)^ : _ = Df).
    destruct e.
    intro p. apply hypothesis.
  - apply ap, Family.map_commutes.
Defined.

(* If we know how to map the closure system [C] to the closure system [D],
   then we can map any derivation in [C] to a derivation in [D]. *)
Local Fixpoint map_derivation {X} {C D : system X} (f : map C D) {H} {x} (d : derivation C H x) :
  derivation D H x.
Proof.
  destruct d.
  - now apply hypothesis.
  - apply (@graft X D (rule_premises (C r))).
    + now apply f.
    + intro i.
      now apply (map_derivation _ C _ f).
Defined.
