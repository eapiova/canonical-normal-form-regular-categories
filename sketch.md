notes/plans towards (formalised) general definition of type theory, for Ljubljana visit?

Background:

- families
- families monadic: Fam(Fam(T)) —> Fam(T) etc. 
- well-founded relations
- infrastructure for “dependently-typed families over well-founded relations”??  Maybe: give on case-by-case to start, then see what’s needed.

Pre-contexts:

- a family of sets
- with coproducts
- and with a coproduct-with-1 operation,

Raw signatures:

- DON’T assume finitary; don’t use lists!  Use *families* for everything?
- syntactic classes: Term, Type
- arities: a syntactic class (for the output), & a family of “argument arities”; where an argument-arity is a synt class and a pre-context 
- raw binding-signatures: a family of arities
- raw syntax, for a binding-signature: inductive family, dependent over pre-contexts
- raw context: a pre-context, plus map from its variables to raw types over that pre-context
- raw context morphisms: function between their pre-contexts, together with a family of terms of the source pre-context, indexed byt the target pre-cxt

Substitution on raw syntax

- along raw context morphisms, into raw types/terms
- [todo: fill in lemmas as needed]

Algebraic extensions (i.e. extensions by “metavariables”):

- def: a family of “simple arities”, i.e. only term-class args, and no bindings, and indexed by some pre-context
- instantiations of metavariables, *relative to a context*.  (This is where we use coproducts of pre-contexts.)
- map of raw syntax induced by an instantiation (uses substitution)
- (POSSIBLY go via: signature morphisms.  An instantiation induces a signature morphism; a signature morphism induces a map of syntax.  But the rôle of the context is then unclear.)

Judgements:

- judgement forms
- (how to relate to boundaries/presuppositions?)
- judgement form instances
- judgement instances (just “judgement”?) (and: relative to a boundary instance?)
- a boundary instance yields a family of judgement instances
- judgement relation (“system” since includes multiple relations?)
- closure condition
- judgement system generated by family of closure conditions

Raw rule (over signature):
- algebraic extension of signature
- family of premises:
- TWO OPTIONS for what premises are:
- 1 (rejected): raw judgements over extended signature (no assumption for now about form!)
- 2 (accepted): judgement *boundaries*, plus (if head needed) a choice of metavariable of appropriate arity
- [question: which direction to link the contexts of the premises to the arities of the metavariables? similarly, later, how to link the index-sets of the families of premises, and their contexts, to the constructors being introduced?]
- conclusion: raw judgement (?boundary) over extended signature

- raw rule over a signature “pushes forward” along any morphism of signatures, in particular along inclusion of signature into its algebraic extension

Rule instances:
- rule instantiation: a context, and some instantiation of the rule’s metavariables, *relative to that context*
- rule instance gives closure condition: if all premises hold then conclusion holds

Raw type theory, over a signature:
- for every algebraic extension of the signature, a family of closure conditions over that alg extn?
- (maybe here, or maybe later) …such that the map of syntax induced by any instantiation respects derivability? or acts on the closure conditions?
- raw type theory induced by family of rules

Well-formed rule, relative to a raw type theory
- well-ordering of premises
- such that for each premise: 
- under 1: not sure
- under 2: the instantiated boundary is derivable over the 

Verbose rule-presented type theory
- includes all structural rules, including congruence rules for constructors etc.
- well-ordered family of rules, each well-formed relative to the raw type theory given by the earlier rules
- (a family of rules gives a family of closure conditions over any extension of the signature)

Streamlined rule-presented type theory
- family of just the “logical rules”
- for each logical rule, say how to give derived structural rules

Proof-of-concept theorems/goals:

- derivability of presuppositions of any derivable judgement
- “typability of subterms”
- assuming substitution in structural rules: Yoneda-style equivalence between absolute and parametric forms of rules, e.g. for pairing, whether to have premises Γ |— a:A, Γ |— b:B[a/x], and conclusion Γ |— <a,b> : Σ_{x:A} B(x); or else no such premises, conclusion as Γ, x:A, y:B(x) |— <x,y> : Σ_{x:A} B(x).
- give the standard rules; show they’re rules!

“Not enough rules/closure conditions” is the more typical pitfall than “too many”.  “Too many” is not really ruled out by the above — but “enough” is reasonably justified by them, if we can give the standard rules + these various metatheorems.

To rule out “too many”: give a model!  Beyond scope of current project??  Perhaps: toy example — give a *really super-simple* type theory — e.g. two base types — and show that they’re not derivably judgementally equal?  How easy?

Serious theorems:

- conservativity of logical framework

- Peter Aczel “generalised Church-Rosser”??







