# Project goals

## Main definitions

- definition of a well-specified type theory

## Smaller goal theorems

Theorems/lemmas that would give nice examples to prove, once the main definition is set up, and which should be reasonably straightforward to state+prove

- Well-typedness of associated congruence rules (whenever an original rule-spec is well-typed).

- Equivalence of the “hypothetical” and “absolute” forms of a rule — e.g. pairing rule with components as premises, or as context of conclusion.

- Derivability of presuppositions of any derivable judgement.

- General inversion lemma.  Given any derivable judgement, and any immediate subterm of the head (or even: any subterm of any expression involved), should be able to formulate and derive another judgement with that subterm as the head.

- Equivalence of a rule given with all premises vs. given with the “inferrable” premises omitted.  (Subtlety: what should “equivalent” mean in this and other lemmas? want it to hold just for the theory leading up to + including the given rule, or for further (reasonable) extensions?  If the latter, how to prove it?)

## Larger goal theorems

- Some approach to raising the “inferrable premises can be omitted” theorem to whole type theories!  (Either automatically seek premises to omit when translating the rule-specs, or have it human-specified.)

- Uniqueness of typing?

- Syntax forms a contextual category / CwA / etc

# Original sketch

[PLL’s notes preceding Ljubljana visit, Dec 2016.  TODO: organise these a bit, + bring up to date with subsequent improvements]

notes/plans towards (formalised) general definition of type theory, for Ljubljana visit?

Background:

- families
- families monadic: Fam(Fam(T)) —> Fam(T) etc. 
- well-founded relations
- infrastructure for “dependently-typed families over well-founded relations”??  Maybe: give on case-by-case to start, then see what’s needed.

Pre-contexts:

- a family of sets
- with coproducts
- and with a coproduct-with-1 operation,

Raw signatures:

- DON’T assume finitary; don’t use lists!  Use *families* for everything?
- syntactic classes: Term, Type
- arities: a syntactic class (for the output), & a family of “argument arities”; where an argument-arity is a synt class and a pre-context 
- raw binding-signatures: a family of arities
- raw syntax, for a binding-signature: inductive family, dependent over pre-contexts
- raw context: a pre-context, plus map from its variables to raw types over that pre-context
- raw context morphisms: together with a family of terms of the source pre-context, indexed byt the target pre-cxt

Substitution on raw syntax

- along raw context morphisms, into raw types/terms
- [todo: fill in lemmas as needed]

Algebraic extensions (i.e. extensions by “metavariables”):

- specified by an arity
- instantiations of metavariables, *relative to a context*.  (This is where we use coproducts of pre-contexts.)
- map of raw syntax induced by an instantiation (uses substitution)
- (POSSIBLY go via: signature morphisms.  An instantiation induces a signature morphism; a signature morphism induces a map of syntax.  But the rôle of the context is then unclear.)

Judgements:

- judgement forms
- (how to relate to boundaries/presuppositions?)
- judgement form instances
- judgement instances (just “judgement”?) (and: relative to a boundary instance?)
- a boundary instance yields a family of judgement instances
- judgement relation (“system” since includes multiple relations?)
- closure condition
- judgement system generated by family of closure conditions

Raw rule (over signature):
- *arity*, specifying an algebraic extension of signature;
- family of premises:
- TWO OPTIONS for what premises are:
- 1 (decided better, 2016-11-22): raw judgements over extended signature (no assumption for now about form!)
- 2: judgement *boundaries*, plus (if head needed) a choice of metavariable of appropriate arity
- [question: which direction to link the contexts of the premises to the arities of the metavariables? similarly, later, how to link the index-sets of the families of premises, and their contexts, to the constructors being introduced?]
- conclusion: raw judgement over extended signature

- lemma: raw rule over a signature “pushes forward” along any morphism of signatures, in particular along inclusion of signature into its algebraic extension

Rule instances:
- rule instantiation: a context, and some instantiation of the rule’s “metavariables”, *relative to that context*
- rule instance gives closure condition: if all premises hold then conclusion holds

Raw type theory, over a signature:
- for every algebraic extension of the signature, a family of closure conditions over that alg extn?
- (maybe here, or maybe later) …such that the map of syntax induced by any instantiation respects derivability? or acts on the closure conditions?
- raw type theory induced by family of rules

Well-formed rule, relative to a raw type theory
- well-ordering of premises
- such that for each premise: 
- under 1: not sure
- under 2: the instantiated boundary is derivable over the 

Verbose rule-presented type theory
- includes all structural rules, including congruence rules for constructors etc.
- well-ordered family of rules, each well-formed relative to the raw type theory given by the earlier rules
- (a family of rules gives a family of closure conditions over any extension of the signature)

Streamlined rule-presented type theory
- family of just the “logical rules”
- for each logical rule, say how to give derived structural rules

Proof-of-concept theorems/goals:

- derivability of presuppositions of any derivable judgement
- “typability of subterms”
- assuming substitution in structural rules: Yoneda-style equivalence between absolute and parametric forms of rules, e.g. for pairing, whether to have premises Γ |— a:A, Γ |— b:B[a/x], and conclusion Γ |— <a,b> : Σ_{x:A} B(x); or else no such premises, conclusion as Γ, x:A, y:B(x) |— <x,y> : Σ_{x:A} B(x).
- give the standard rules; show they’re rules!

“Not enough rules/closure conditions” is the more typical pitfall than “too many”.  “Too many” is not really ruled out by the above — but “enough” is reasonably justified by them, if we can give the standard rules + these various metatheorems.

To rule out “too many”: give a model!  Beyond scope of current project??  Perhaps: toy example — give a *really super-simple* type theory — e.g. two base types — and show that they’re not derivably judgementally equal?  How easy?

Serious theorems:

- conservativity of logical framework

- Peter Aczel “generalised Church-Rosser”??

